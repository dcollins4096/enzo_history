c---------------------------------------------------------------------------
C
C     NAME = QROMO 
C
      SUBROUTINE QROMO(FUNC,A,B,SS,CHOOSE)
C
C     ROMBERG INTEGRATION ON AN OPEN INTERVAL. RETURNS AS SS
C     THE INTEGRAL OF THE FUNCTION FUNC FROM A TO B. USING
C     ANY SPECIFIED INTEGRATING SUNROUTINE "CHOOSE" AND
C     ROMBERG'S' METHOD. NORMALLY "CHOOSE" WILL BE AN OPEN
C     FORMULA, NOT EVALUATING THE FUNCTION AT THE ENDPOINTS.
C     IT IS ASSUMED THAT "CHOOSE" TRIPLES THE NUMBER OF STEPS
C     ON EACH CALL, AND THAT ITS ERROR SERIES CONTAINS ONLY
C     EVEN POWERS OF THE NUMBER OF STEPS. THE ROUTINES
C     "MIDPNT", "MIDINF", "MIDSQL", "MIDSQU", ARE POSSIBLE
C     CHOICES FOR "CHOOSE".
C
      PARAMETER (EPS=1.E-6,JMAX=18,JMAXP=JMAX+1,KM=4,K=KM+1)
      EXTERNAL CHOOSE
      DIMENSION S(JMAXP),H(JMAXP)
c     WRITE(*,*)'QROMO START'
      H(1)=1.
      DO 11 J=1,JMAX
        CALL CHOOSE(FUNC,A,B,S(J),J)
        IF (J.GE.K) THEN
          CALL POLINT(H(J-KM),S(J-KM),K,0.0,SS,DSS)
c          write(6,*) j,dss,ss,s(j)
          IF (ABS(DSS) .LT. (EPS*ABS(SS)) ) RETURN
        ENDIF
        S(J+1)=S(J)
C
        H(J+1)=H(J)/9.
C     THIS IS WHERE THE ASSUMPTION OF STEP TRIPLING AND AN
C     EVEN ERROR SERIES IS USED.
C
  11  CONTINUE
      STOP 'TOO MANY STEPS.'
      END



c---------------------------------------------------------------------------
C
C     NAME = POLINT
C
      SUBROUTINE POLINT(XA,YA,N,X,Y,DY)
C
C     THIS IS A ROUTINE FOR POLYNOMIAL INTERPOLATION OR 
C     EXTRAPOLATION. GEVEN ARRAYS XA AND YA, EACH OF LENTH
C     N, AND VALUE X, THIS ROUTINE WILL RETURN A VALUE Y,
C     AND AN ERROR ESTIMATOR DY. IF P(X) IS THE POLYNOMIAL
C     OF DEGREE N-1 SUCH THAT P(XA_J)=YA_J, J=1,...,N, THEN
C     THE RETURNED VALUE Y=P(X).
C
      PARAMETER (NMAX=10) 
C     CHANGE NMAX AS DESIRED TO BE THE LARGEST ANTICIPATED
C     VALUE OF N.
C
      DIMENSION XA(N),YA(N),C(NMAX),D(NMAX)
      NS=1
      DIF=ABS(X-XA(1))
      DO 11 I=1,N 
C     HERE WE FIND THE INDEX NS OF THE CLOSEST TABLE ENTRY.
C
        DIFT=ABS(X-XA(I))
        IF (DIFT.LT.DIF) THEN
          NS=I
          DIF=DIFT
        ENDIF
        C(I)=YA(I)
C     AND INITIALIZE THE TABLEAU OF C'S' AND D'S'.
C
        D(I)=YA(I)
   11 CONTINUE
      Y=YA(NS)
C     THIS IS THE INITIAL APPROMATION TO Y.
C
      NS=NS-1
      DO 13 M=1,N-1
C     FOR EACH COLUMN OF THE TABLEAU,
        DO 12 I=1,N-M
C     WE LOOP OVER THE CURRENT C'S' AND D'S' AND UPDATE THEM.
C
          HO=XA(I)-X
          HP=XA(I+M)-X
          W=C(I+1)-D(I)
          DEN=HO-HP
          IF(DEN.EQ.0.) STOP 'DEN = 0'
C     THIS ERROR CAN ONLY OCCUR IF TWO INPUT XA'S' ARE(TO WITHIN
C     ROUNDOFF) IDENTICAL.
C
          DEN=W/DEN
          D(I)=HP*DEN
C     HERE THE C'S' AND D'S' ARE UPDATED.
C
          C(I)=HO*DEN
   12   CONTINUE
        IF (2*NS.LT.N-M)THEN
C     AFTER EACH COLUMN IN THE TABLEAU IS COMPLETED, WE
C     DECIDED WHICH CORRECTION , C OR D, WE WANT TO ADD 
C     TO OUR ACCUMULATING VALUE OF Y, I.E. WHICH PATH TO
C     TAKE THROUGH THE TABLEAU --- FORKING UP OR DOWN.
C     WE DO THIS IN SUCH A WAY AS TO TAKE THE MOST 
C     "STRAIGHT LINE" ROUTE THROUGH THE TABLEAU TO ITS APEX,
C     UPDATING NS ACCORDINGLY TO KEEP TRACK OF WHERE WE ARE.
C     THIS ROUTE KEEPS THE PARTIAL APPROXIMATIONA CENTERED
C     (INSOFAR AS POSSIBLE) ON THE TARGET X. THE LAST DY
C     ADDED IS THUS THE ERROR INDICATION.
C
          DY=C(NS+1)
        ELSE
          DY=D(NS)
          NS=NS-1
        ENDIF
        Y=Y+DY
   13 CONTINUE
      RETURN
      END



c---------------------------------------------------------------------------
C
C     NAME MIDINF
C
      SUBROUTINE MIDINF(FUNK,AA,BB,S,N)
C
      SAVE IT
C
C     THIS SUBROUTINE IS AN EXACT REPLACEMENT FOR "MIDPNT",
C     I.E. RETURNS AS "S" THE N-TH STAGE OF REFINEMENT OF THE
C     INTEGRAL OF "FUNC" FROM AA TO BB, EXCEPT THAT THE FUNCTION
C     IS EVALUATED AT EVENLY SPACED POINTS IN 1/X RATHER THAN 
C     IN X. THIS ALLOWS THE UPPER LIMIT BB TO BE AS LARGE AND
C     POSITIVE AS THE COMPUTER ALLOWS, OR THE LOWER LIMIT AA
C     TO BE AS LARGE AND NEGATIVE, BUT NOT BOTH. AA AND BB MUST
C     HAVE THE SAME SIGN.
C
      FUNC(X)=FUNK(1./X)/X**2
C
C     THIS IS THE STATEMENT FUNCTION WHICH EFFECTS THE CHANGE
C     OF VARIABLE.
C
      B=1./AA
      A=1./BB
C
C     THESE TWO STATEMENTS CHANGE THE LIMITS OF INTEGRATION
C     ACCORDINGLY.
C
      IF (N.EQ.1) THEN
C
C     FROM THIS POINT ON, THE ROUTINE IS EXACTLY 
C     IDENTICAL TO "MIDPNT".
C
        S=(B-A)*FUNC(0.5*(A+B))
        IT=1
      ELSE
        TNM=IT
        DEL=(B-A)/(3.*TNM)
        DDEL=DEL+DEL
        X=A+0.5*DEL
        SUM=0.
        DO 11 J=1,IT
          SUM=SUM+FUNC(X)
          X=X+DDEL
          SUM=SUM+FUNC(X)
          X=X+DEL
   11   CONTINUE
        S=(S+(B-A)*SUM/TNM)/3.
        IT=3*IT
      ENDIF
      RETURN
      END




c---------------------------------------------------------------------------
C
C
C     NAME = MIDPNT
C
      SUBROUTINE MIDPNT(FUNC,A,B,S,N)
C
      SAVE IT
C
C     THIS ROUTINE COMPUTES THE N-TH STAGE OF REFINEMENT OF AN 
C     EXTENDED MIDPOINT RULE. "FUNC" IS INPUT AS THE NAME OF THE 
C     FUNCTION TO BE INTEGRATED BETWEEN LIMITS A AND B, ALSO INPUT.
C     WHEN CALLED WITH N=1, THE ROUTINE RETURNS AS "S" THE CRUDEST
C     ESTIMATE OF INTEGRAL. SUBSEQUENT CALLS WITH N=2,3,... (IN THAT
C     SEQUENTIAL ORDER) WILL IMPROVE THE ACCURACY OF "S" BY ADDING
C     (2/3)*3^{N-1} ADDITIONAL INTERIOR POINTS. "S" SHOULD NOT BE
C     MODIFIED BETWEEN SEQUENTIAL CALLS.
C
      IF (N.EQ.1) THEN
        S=(B-A)*FUNC(0.5*(A+B))
        IT=1
C     2*IT POINTS WILL BE ADDED ON THE NEXT REFINEMENT
C
      ELSE
        TNM=IT
        DEL=(B-A)/(3.*TNM)
        DDEL=DEL+DEL
        X=A+0.5*DEL
        SUM=0.
        DO 11 J=1,IT
          SUM=SUM+FUNC(X)
          X=X+DDEL
          SUM=SUM+FUNC(X)
          X=X+DEL
   11   CONTINUE
        S=(S+(B-A)*SUM/TNM)/3.
C     THE NEW SUM ID COMBINED WITH THE OLD INTEGRAL TO GIVE
C     A REFINED INTEGRAL.
C
        IT=3*IT
      ENDIF
      RETURN
      END


C---------------------------------------------------------------------------
C
C
C     NAME = MIDSQL
C
      SUBROUTINE MIDSQL(FUNK,AA,BB,S,N)
C
      SAVE IT
C
C     THIS ROUTINE IS AN EXACT REPLACEMENT FOR MIDPNT EXCEPT THAT IT
C     ALLOWS FOR AN INVERSE SQUARE-ROOT SINGULARITY INT THE INTEGRAND
C     AT THE LOWER LIMIT AA
C
C     THIS IS THE STATEMENT FUNCTION WHICH EFFECTS THE CHANGE
C     OF VARIABLE.
C
      FUNC(X)=2.0*X*FUNK(AA+X**2)
C
C     THESE TWO STATEMENTS CHANGE THE LIMITS OF INTEGRATION
C     ACCORDINGLY.
C
      B=SQRT(BB-AA)
      A=0.0
C
      IF (N.EQ.1) THEN
        S=(B-A)*FUNC(0.5*(A+B))
        IT=1
C     2*IT POINTS WILL BE ADDED ON THE NEXT REFINEMENT
C
      ELSE
        TNM=IT
        DEL=(B-A)/(3.*TNM)
        DDEL=DEL+DEL
        X=A+0.5*DEL
        SUM=0.
        DO 11 J=1,IT
          SUM=SUM+FUNC(X)
          X=X+DDEL
          SUM=SUM+FUNC(X)
          X=X+DEL
   11   CONTINUE
        S=(S+(B-A)*SUM/TNM)/3.
C     THE NEW SUM ID COMBINED WITH THE OLD INTEGRAL TO GIVE
C     A REFINED INTEGRAL.
C
        IT=3*IT
      ENDIF
      RETURN
      END


C---------------------------------------------------------------------------
C
C
C     NAME = MIDSQU
C
      SUBROUTINE MIDSQU(FUNK,AA,BB,S,N)
C
      SAVE IT
C
C     THIS ROUTINE IS AN EXACT REPLACEMENT FOR MIDPNT EXCEPT THAT IT
C     ALLOWS FOR AN INVERSE SQUARE-ROOT SINGULARITY INT THE INTEGRAND
C     AT THE UPPER LIMIT BB
C
C     THIS IS THE STATEMENT FUNCTION WHICH EFFECTS THE CHANGE
C     OF VARIABLE.
C
      FUNC(X)=2.0*X*FUNK(BB-X**2)
C
C     THESE TWO STATEMENTS CHANGE THE LIMITS OF INTEGRATION
C     ACCORDINGLY.
C
      B=SQRT(BB-AA)
      A=0.0
C
      IF (N.EQ.1) THEN
        S=(B-A)*FUNC(0.5*(A+B))
        IT=1
C     2*IT POINTS WILL BE ADDED ON THE NEXT REFINEMENT
C
      ELSE
        TNM=IT
        DEL=(B-A)/(3.*TNM)
        DDEL=DEL+DEL
        X=A+0.5*DEL
        SUM=0.
        DO 11 J=1,IT
          SUM=SUM+FUNC(X)
          X=X+DDEL
          SUM=SUM+FUNC(X)
          X=X+DEL
   11   CONTINUE
        S=(S+(B-A)*SUM/TNM)/3.
C     THE NEW SUM ID COMBINED WITH THE OLD INTEGRAL TO GIVE
C     A REFINED INTEGRAL.
C
        IT=3*IT
      ENDIF
      RETURN
      END
